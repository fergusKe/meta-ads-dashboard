# 系統優化建議報告

> 基於全面分析的 17 項優化建議，讓系統更強大、更穩定、更易用

## ✅ 實作進度
- Agent 快取系統：`utils/cache_manager.py`、`pages/27_🗄️_快取管理.py`
- 統一錯誤處理：`utils/error_handler.py` 套用至 Copywriting/Optimization 等核心 Agent
- 智能模型選擇：`utils/model_selector.py` 與個人化設定 `pages/31_⚙️_個人化偏好.py`
- 多 Key 輪替與成本監控：`utils/api_keys.py`、`utils/llm_service.py`、`pages/28_📊_效能與成本儀表板.py`
- 執行歷史與匯出：`utils/history_manager.py`、`pages/30_📜_Agent執行歷史.py`
- A/B 測試框架：`utils/experiments.py`、`pages/29_🧪_A_B_測試控制台.py`
- 其他工具：`utils/progress.py`、`utils/security.py`、`utils/exporter.py` 等


**分析日期**：2025-10-06
**當前版本**：3.0
**系統規模**：17 個 Agent + 25 個頁面 + 11,729 行程式碼

---

## 🎯 優先級分類

- 🔴 **高優先級**（建議立即實施）- 直接影響穩定性與用戶體驗
- 🟡 **中優先級**（建議近期實施）- 提升效能與開發效率
- 🟢 **低優先級**（長期規劃）- 增強功能與擴展性

---

## 📊 Category 1：效能與成本優化

### 🔴 1. Agent 結果快取機制

**現況問題**：
- 每次生成都重新呼叫 API，成本高、速度慢
- 相同參數的請求重複計算
- 無快取導致用戶等待時間長

**建議方案**：
```python
# utils/agents/cache_manager.py
import hashlib
import json
from functools import wraps
from datetime import datetime, timedelta

class AgentCache:
    """Agent 結果快取管理"""

    def __init__(self, ttl_seconds=3600):
        self.cache = {}
        self.ttl = ttl_seconds

    def get_cache_key(self, agent_name, params):
        """生成快取 key"""
        content = f"{agent_name}:{json.dumps(params, sort_keys=True)}"
        return hashlib.md5(content.encode()).hexdigest()

    def get(self, key):
        """獲取快取"""
        if key in self.cache:
            result, timestamp = self.cache[key]
            if datetime.now() - timestamp < timedelta(seconds=self.ttl):
                return result
            else:
                del self.cache[key]
        return None

    def set(self, key, value):
        """設定快取"""
        self.cache[key] = (value, datetime.now())

# 在每個 Agent 中使用
def cache_agent_result(cache_key_params):
    def decorator(func):
        @wraps(func)
        async def wrapper(self, *args, **kwargs):
            cache = st.session_state.get('agent_cache')
            if not cache:
                cache = AgentCache(ttl_seconds=3600)
                st.session_state['agent_cache'] = cache

            key = cache.get_cache_key(
                self.__class__.__name__,
                cache_key_params(args, kwargs)
            )

            cached = cache.get(key)
            if cached:
                st.info("✨ 使用快取結果（節省成本）")
                return cached

            result = await func(self, *args, **kwargs)
            cache.set(key, result)
            return result
        return wrapper
    return decorator
```

**預期效益**：
- 💰 節省 API 成本 40-60%
- ⚡ 相同查詢響應速度提升 10-100 倍
- 😊 用戶體驗大幅提升

---

### 🟡 2. 批次處理與並行執行

**現況問題**：
- Agent 工具串行執行，速度慢
- 多個獨立 Agent 未並行處理
- 數據載入無批次優化

**建議方案**：
```python
import asyncio

# 在 Agent 中並行執行工具
async def parallel_tools_execution(self, tools_to_run):
    """並行執行多個工具"""
    tasks = [tool() for tool in tools_to_run]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    return results

# 頁面中並行執行多個 Agent
async def run_multiple_agents():
    """並行執行多個 Agent"""
    agent1 = CopywritingAgent()
    agent2 = ImagePromptAgent()

    results = await asyncio.gather(
        agent1.generate_copy(...),
        agent2.generate_prompts(...),
        return_exceptions=True
    )
    return results
```

**預期效益**：
- ⚡ 多 Agent 頁面速度提升 2-3 倍
- 🎯 更好的資源利用率

---

### 🟢 3. 智能模型選擇

**現況問題**：
- 所有 Agent 統一使用 gpt-5-nano
- 未根據任務複雜度選擇模型
- 簡單任務可用更便宜模型，複雜任務需要更強模型

**建議方案**：
```python
class ModelSelector:
    """根據任務複雜度選擇模型"""

    MODELS = {
        'simple': 'gpt-5-nano',      # 簡單任務
        'medium': 'gpt-4o-mini',     # 中等複雜度
        'complex': 'gpt-4o',         # 複雜任務
        'vision': 'gemini-2.5-flash-image'  # 圖片相關
    }

    @staticmethod
    def select_model(task_type, complexity='medium'):
        """選擇合適模型"""
        if task_type == 'vision':
            return ModelSelector.MODELS['vision']
        return ModelSelector.MODELS.get(complexity, 'gpt-5-nano')

# 在 Agent 中使用
class DynamicAgent:
    def __init__(self, task_complexity='medium'):
        model = ModelSelector.select_model('text', task_complexity)
        self.agent = Agent(f'openai:{model}', ...)
```

**預期效益**：
- 💰 成本優化 20-30%
- 📈 複雜任務品質提升

---

## 🛡️ Category 2：穩定性與錯誤處理

### 🔴 4. 統一錯誤處理與重試機制

**現況問題**：
- 各 Agent 錯誤處理不一致
- API 失敗無自動重試
- 錯誤訊息對用戶不友善

**建議方案**：
```python
# utils/error_handler.py
from functools import wraps
import time

class AgentErrorHandler:
    """統一錯誤處理"""

    @staticmethod
    def handle_errors(max_retries=3, backoff=2):
        def decorator(func):
            @wraps(func)
            async def wrapper(*args, **kwargs):
                for attempt in range(max_retries):
                    try:
                        return await func(*args, **kwargs)
                    except openai.RateLimitError as e:
                        if attempt < max_retries - 1:
                            wait_time = backoff ** attempt
                            st.warning(f"⏳ API 配額限制，{wait_time}秒後重試...")
                            time.sleep(wait_time)
                        else:
                            st.error("❌ API 配額已達上限，請稍後再試")
                            raise
                    except openai.APIError as e:
                        st.error(f"❌ API 錯誤：{str(e)}")
                        raise
                    except Exception as e:
                        st.error(f"❌ 未預期錯誤：{str(e)}")
                        with st.expander("🔍 詳細錯誤資訊"):
                            st.code(traceback.format_exc())
                        raise
            return wrapper
        return decorator

# 在所有 Agent 的執行方法加上裝飾器
@AgentErrorHandler.handle_errors(max_retries=3)
async def generate_copy(self, ...):
    ...
```

**預期效益**：
- 🛡️ 穩定性提升 80%
- 😊 用戶體驗更好
- 🐛 問題更容易定位

---

### 🔴 5. 日誌與監控系統

**現況問題**：
- 無系統化日誌記錄
- 無法追蹤 Agent 執行狀況
- 無法分析失敗原因

**建議方案**：
```python
# utils/logger.py
import logging
from datetime import datetime
import json

class AgentLogger:
    """Agent 日誌系統"""

    def __init__(self, log_file="logs/agent_execution.log"):
        self.logger = logging.getLogger('AgentLogger')
        self.logger.setLevel(logging.INFO)

        # 檔案處理器
        fh = logging.FileHandler(log_file)
        fh.setLevel(logging.INFO)

        # 格式化
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        fh.setFormatter(formatter)
        self.logger.addHandler(fh)

    def log_agent_execution(self, agent_name, params, result, duration):
        """記錄 Agent 執行"""
        log_data = {
            'timestamp': datetime.now().isoformat(),
            'agent': agent_name,
            'params': params,
            'success': result is not None,
            'duration_seconds': duration,
            'tokens_used': getattr(result, 'usage', None)
        }
        self.logger.info(json.dumps(log_data, ensure_ascii=False))

    def log_error(self, agent_name, error, params):
        """記錄錯誤"""
        self.logger.error(f"Agent: {agent_name}, Error: {str(error)}, Params: {params}")

# 整合 Pydantic AI 的 Logfire
import logfire

logfire.configure()

# 在 Agent 中啟用
class MonitoredAgent:
    def __init__(self):
        logfire.instrument_pydantic_ai()
        self.agent = Agent(...)
```

**預期效益**：
- 📊 完整執行記錄
- 🐛 快速定位問題
- 📈 成本與效能分析

---

### 🟡 6. API Key 輪替與配額管理

**現況問題**：
- 單一 API Key，配額用完就卡住
- 無配額監控
- 無成本控制

**建議方案**：
```python
# utils/api_manager.py
class APIKeyManager:
    """API Key 管理與輪替"""

    def __init__(self):
        self.keys = {
            'primary': os.getenv('OPENAI_API_KEY'),
            'backup1': os.getenv('OPENAI_API_KEY_BACKUP1'),
            'backup2': os.getenv('OPENAI_API_KEY_BACKUP2'),
        }
        self.current_key = 'primary'
        self.usage = {key: 0 for key in self.keys}
        self.daily_limit = 100  # USD

    def get_key(self):
        """取得可用的 Key"""
        if self.usage[self.current_key] >= self.daily_limit:
            self._switch_key()
        return self.keys[self.current_key]

    def _switch_key(self):
        """切換到備用 Key"""
        for key_name in ['backup1', 'backup2']:
            if self.usage[key_name] < self.daily_limit:
                self.current_key = key_name
                st.info(f"🔄 切換到備用 API Key: {key_name}")
                return
        st.error("❌ 所有 API Key 都已達配額上限")

    def record_usage(self, cost):
        """記錄使用量"""
        self.usage[self.current_key] += cost
```

**預期效益**：
- 🔄 自動容錯切換
- 💰 成本可控
- 📊 用量透明

---

## 🚀 Category 3：功能增強

### 🟡 7. Agent 執行歷史與比較

**現況問題**：
- 無法查看歷史生成結果
- 無法比較不同版本
- 無法追蹤優化效果

**建議方案**：
```python
# utils/agent_history.py
class AgentHistory:
    """Agent 執行歷史管理"""

    def __init__(self):
        self.history_file = "data/agent_history.json"

    def save_result(self, agent_name, params, result):
        """儲存結果"""
        history = self._load_history()

        entry = {
            'timestamp': datetime.now().isoformat(),
            'agent': agent_name,
            'params': params,
            'result': result.model_dump() if hasattr(result, 'model_dump') else str(result),
            'id': hashlib.md5(f"{agent_name}{datetime.now()}".encode()).hexdigest()[:8]
        }

        history.append(entry)
        self._save_history(history)
        return entry['id']

    def get_history(self, agent_name, limit=10):
        """取得歷史記錄"""
        history = self._load_history()
        filtered = [h for h in history if h['agent'] == agent_name]
        return filtered[-limit:]

    def compare_results(self, result_id1, result_id2):
        """比較兩個結果"""
        history = self._load_history()
        r1 = next(h for h in history if h['id'] == result_id1)
        r2 = next(h for h in history if h['id'] == result_id2)
        return {'result1': r1, 'result2': r2, 'diff': self._calculate_diff(r1, r2)}

# 在頁面中使用
history = AgentHistory()

# 儲存結果
result_id = history.save_result('CopywritingAgent', params, result)

# 顯示歷史
with st.expander("📚 查看歷史生成結果"):
    past_results = history.get_history('CopywritingAgent', limit=5)
    for r in past_results:
        st.write(f"**{r['timestamp']}** - ID: {r['id']}")
        if st.button(f"載入此結果", key=r['id']):
            st.session_state['loaded_result'] = r['result']
```

**預期效益**：
- 📚 結果可追溯
- 🔄 快速重用歷史結果
- 📊 A/B 測試更容易

---

### 🟡 8. 自動化測試框架

**現況問題**：
- 只有 1 個測試檔案
- Agent 無自動化測試
- 重構時無法保證功能正常

**建議方案**：
```python
# tests/test_agents.py
import pytest
from utils.agents import CopywritingAgent

class TestCopywritingAgent:
    """CopywritingAgent 測試"""

    @pytest.fixture
    def agent(self):
        return CopywritingAgent()

    @pytest.mark.asyncio
    async def test_generate_copy_basic(self, agent):
        """測試基本文案生成"""
        result = await agent.generate_copy(
            product_name="測試產品",
            target_audience="25-35歲上班族",
            campaign_goal="提升品牌知名度",
            tone="專業"
        )

        assert len(result.variants) >= 3
        assert len(result.variants) <= 5
        assert result.strategy_explanation != ""
        assert len(result.ab_test_suggestions) > 0

    @pytest.mark.asyncio
    async def test_output_validation(self, agent):
        """測試 Pydantic 驗證"""
        result = await agent.generate_copy(...)

        # 驗證結構完整性
        for variant in result.variants:
            assert variant.headline != ""
            assert variant.primary_text != ""
            assert variant.cta != ""
            assert len(variant.headline) <= 100

# tests/test_integration.py
class TestIntegration:
    """整合測試"""

    @pytest.mark.asyncio
    async def test_copywriting_to_image_flow(self):
        """測試文案生成 -> 圖片生成流程"""
        copywriting_agent = CopywritingAgent()
        image_agent = ImagePromptAgent()

        # 生成文案
        copy_result = await copywriting_agent.generate_copy(...)

        # 使用文案生成圖片提示詞
        image_result = await image_agent.generate_prompts(
            copy_context=copy_result.variants[0].primary_text
        )

        assert image_result is not None
        assert len(image_result.variants) == 3

# 設定 GitHub Actions
# .github/workflows/test.yml
name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.10'
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-asyncio
      - name: Run tests
        run: pytest tests/ -v
```

**預期效益**：
- 🛡️ 防止功能退化
- 🚀 重構更有信心
- 📊 程式碼品質可量化

---

### 🟢 9. Agent 間協作與工作流

**現況問題**：
- Agent 各自獨立運作
- 無法串連形成工作流
- 需手動在頁面間切換

**建議方案**：
```python
# utils/workflows/campaign_workflow.py
class CampaignCreationWorkflow:
    """廣告活動創建工作流"""

    def __init__(self):
        self.strategy_agent = StrategyAgent()
        self.copywriting_agent = CopywritingAgent()
        self.image_agent = ImagePromptAgent()
        self.optimization_agent = OptimizationAgent()

    async def create_campaign(self, brief):
        """一鍵創建完整廣告活動"""

        # Step 1: 策略規劃
        strategy = await self.strategy_agent.plan_strategy(
            product=brief['product'],
            budget=brief['budget'],
            goal=brief['goal']
        )

        # Step 2: 文案生成（基於策略）
        copy_results = await self.copywriting_agent.generate_copy(
            target_audience=strategy.target_audience,
            tone=strategy.recommended_tone,
            key_messages=strategy.key_messages
        )

        # Step 3: 圖片提示詞（基於文案）
        image_prompts = await self.image_agent.generate_prompts(
            copy_context=copy_results.variants[0].primary_text,
            style=strategy.visual_style
        )

        # Step 4: 優化建議
        optimization = await self.optimization_agent.analyze(
            copy=copy_results,
            images=image_prompts,
            strategy=strategy
        )

        return {
            'strategy': strategy,
            'copy': copy_results,
            'images': image_prompts,
            'optimization': optimization
        }

# 在新頁面使用
st.title("🚀 一鍵創建廣告活動")

if st.button("開始創建"):
    workflow = CampaignCreationWorkflow()

    with st.spinner("🤖 AI 正在創建完整廣告活動..."):
        result = await workflow.create_campaign(brief)

    st.success("✅ 廣告活動創建完成！")

    # 顯示所有結果
    tabs = st.tabs(["策略", "文案", "圖片", "優化建議"])
    with tabs[0]:
        st.write(result['strategy'])
    # ...
```

**預期效益**：
- 🚀 效率提升 5-10 倍
- 🎯 AI 協作更智能
- 😊 用戶體驗質的飛躍

---

## 📱 Category 4：用戶體驗

### 🟡 10. 即時進度與取消功能

**現況問題**：
- Agent 執行時間長，無進度顯示
- 無法中途取消
- 用戶不知道要等多久

**建議方案**：
```python
# 在 Agent 執行中加入進度回報
class ProgressTracker:
    """進度追蹤"""

    def __init__(self, total_steps):
        self.total = total_steps
        self.current = 0
        self.placeholder = st.empty()

    def update(self, step_name):
        """更新進度"""
        self.current += 1
        progress = self.current / self.total
        self.placeholder.progress(
            progress,
            text=f"步驟 {self.current}/{self.total}: {step_name}"
        )

    def complete(self):
        """完成"""
        self.placeholder.success("✅ 完成！")

# 在 Agent 中使用
async def generate_copy_with_progress(self, ...):
    tracker = ProgressTracker(total_steps=5)

    tracker.update("載入 RAG 知識庫")
    rag_data = await self._load_rag()

    tracker.update("分析受眾特徵")
    audience = await self._analyze_audience()

    tracker.update("生成文案變體")
    variants = await self._generate_variants()

    tracker.update("Pydantic 驗證")
    result = self._validate(variants)

    tracker.update("後處理與優化")
    final = self._post_process(result)

    tracker.complete()
    return final

# 加入取消按鈕
cancel_button = st.button("❌ 取消執行")
if cancel_button:
    st.session_state['cancel_flag'] = True
    st.warning("⏸️ 正在取消...")

# 在 Agent 執行過程檢查
if st.session_state.get('cancel_flag'):
    st.session_state['cancel_flag'] = False
    raise CancelledException("用戶取消執行")
```

**預期效益**：
- 😊 用戶焦慮降低
- 🎯 可控性提升
- ⏱️ 時間預期更準確

---

### 🟡 11. 個人化設定與偏好

**現況問題**：
- 無法儲存用戶偏好
- 每次都要重新輸入參數
- 無客製化選項

**建議方案**：
```python
# utils/user_preferences.py
class UserPreferences:
    """用戶偏好管理"""

    def __init__(self):
        if 'user_prefs' not in st.session_state:
            st.session_state['user_prefs'] = self._load_defaults()

    def save_preference(self, category, key, value):
        """儲存偏好"""
        st.session_state['user_prefs'][category][key] = value
        self._persist_to_file()

    def get_preference(self, category, key, default=None):
        """取得偏好"""
        return st.session_state['user_prefs'].get(category, {}).get(key, default)

    def _load_defaults(self):
        return {
            'copywriting': {
                'default_tone': '專業溫暖',
                'default_length': '中等',
                'enable_rag': True
            },
            'image': {
                'default_style': '現代簡約',
                'default_size': '1:1',
            },
            'general': {
                'theme': 'light',
                'show_debug': False,
                'auto_save_history': True
            }
        }

# 在頁面中使用
prefs = UserPreferences()

# 使用儲存的偏好作為預設值
tone = st.selectbox(
    "語氣風格",
    ["專業溫暖", "活潑年輕", "典雅傳統"],
    index=["專業溫暖", "活潑年輕", "典雅傳統"].index(
        prefs.get_preference('copywriting', 'default_tone', '專業溫暖')
    )
)

# 儲存偏好
if st.button("💾 記住這些設定"):
    prefs.save_preference('copywriting', 'default_tone', tone)
    st.success("✅ 設定已儲存")
```

**預期效益**：
- ⚡ 提升操作效率
- 😊 個人化體驗
- 🎯 減少重複輸入

---

### 🟢 12. 匯出與分享功能

**現況問題**：
- 生成結果無法匯出
- 無法分享給團隊成員
- 無法整合到其他工具

**建議方案**：
```python
# utils/export_manager.py
class ExportManager:
    """匯出管理"""

    def export_to_pdf(self, content, filename):
        """匯出為 PDF"""
        from reportlab.pdfgen import canvas
        # PDF 生成邏輯
        pass

    def export_to_excel(self, data, filename):
        """匯出為 Excel"""
        df = pd.DataFrame(data)
        buffer = BytesIO()
        df.to_excel(buffer, index=False)
        return buffer.getvalue()

    def export_to_json(self, result):
        """匯出為 JSON"""
        return json.dumps(
            result.model_dump() if hasattr(result, 'model_dump') else result,
            ensure_ascii=False,
            indent=2
        )

    def create_share_link(self, result_id):
        """創建分享連結"""
        # 生成短網址或加密連結
        return f"https://your-domain.com/share/{result_id}"

# 在頁面中使用
exporter = ExportManager()

col1, col2, col3 = st.columns(3)
with col1:
    if st.button("📄 匯出 PDF"):
        pdf = exporter.export_to_pdf(result, "廣告文案.pdf")
        st.download_button("下載 PDF", pdf, "廣告文案.pdf")

with col2:
    if st.button("📊 匯出 Excel"):
        excel = exporter.export_to_excel(result, "廣告文案.xlsx")
        st.download_button("下載 Excel", excel, "廣告文案.xlsx")

with col3:
    if st.button("🔗 分享連結"):
        link = exporter.create_share_link(result_id)
        st.code(link)
        st.success("✅ 連結已複製")
```

**預期效益**：
- 📤 協作更便利
- 💼 商業價值提升
- 🔗 整合其他工具

---

## 🔒 Category 5：安全性與合規

### 🔴 13. 敏感資料處理

**現況問題**：
- API Key 直接寫在 .env（已暴露在文件中）
- 無加密機制
- 歷史記錄可能包含敏感資料

**建議方案**：
```python
# utils/security.py
from cryptography.fernet import Fernet
import os

class SecureStorage:
    """安全儲存"""

    def __init__(self):
        # 從環境變數或 Secrets Manager 取得加密金鑰
        key = os.getenv('ENCRYPTION_KEY') or Fernet.generate_key()
        self.cipher = Fernet(key)

    def encrypt(self, data):
        """加密"""
        return self.cipher.encrypt(data.encode()).decode()

    def decrypt(self, encrypted_data):
        """解密"""
        return self.cipher.decrypt(encrypted_data.encode()).decode()

# 安全儲存 API Key
secure = SecureStorage()
encrypted_key = secure.encrypt(os.getenv('OPENAI_API_KEY'))

# 使用 Streamlit Secrets（推薦）
# .streamlit/secrets.toml
# OPENAI_API_KEY = "sk-..."
# GEMINI_API_KEY = "AIza..."

# 在程式中使用
api_key = st.secrets["OPENAI_API_KEY"]
```

**建議配置**：
```toml
# .streamlit/secrets.toml（不要提交到 Git）
[openai]
api_key = "sk-..."
model = "gpt-5-nano"

[gemini]
api_key = "AIza..."
model = "gemini-2.5-flash-image"

[database]
connection_string = "..."
```

**預期效益**：
- 🔒 安全性大幅提升
- 📋 符合資料保護法規
- 🛡️ 防止金鑰洩漏

---

### 🟡 14. 輸入驗證與清理

**現況問題**：
- 用戶輸入未驗證
- 可能有注入攻擊風險
- 無異常輸入處理

**建議方案**：
```python
# utils/validators.py
import re

class InputValidator:
    """輸入驗證"""

    @staticmethod
    def validate_text_input(text, max_length=1000, allow_special_chars=True):
        """驗證文字輸入"""
        if not text or len(text.strip()) == 0:
            raise ValueError("輸入不能為空")

        if len(text) > max_length:
            raise ValueError(f"輸入長度不能超過 {max_length} 字")

        if not allow_special_chars:
            if not re.match(r'^[\u4e00-\u9fa5a-zA-Z0-9\s]+$', text):
                raise ValueError("輸入包含不允許的特殊字元")

        return text.strip()

    @staticmethod
    def sanitize_filename(filename):
        """清理檔案名稱"""
        return re.sub(r'[^\w\s-]', '', filename).strip()

    @staticmethod
    def validate_url(url):
        """驗證 URL"""
        pattern = re.compile(
            r'^https?://'  # http:// or https://
            r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|'  # domain
            r'localhost|'  # localhost
            r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
            r'(?::\d+)?'  # optional port
            r'(?:/?|[/?]\S+)$', re.IGNORECASE)
        return pattern.match(url) is not None

# 在頁面中使用
validator = InputValidator()

try:
    product_name = validator.validate_text_input(
        st.text_input("產品名稱"),
        max_length=100,
        allow_special_chars=False
    )
except ValueError as e:
    st.error(f"❌ {str(e)}")
    st.stop()
```

**預期效益**：
- 🛡️ 防止惡意輸入
- 📋 資料品質提升
- 🐛 減少異常錯誤

---

## 📊 Category 6：數據與分析

### 🟢 15. Agent 效能分析儀表板

**現況問題**：
- 無法了解各 Agent 的使用情況
- 無法分析成本與效能
- 無數據驅動的優化決策

**建議方案**：
```python
# pages/26_📊_Agent效能分析.py
import streamlit as st
import pandas as pd
import plotly.express as px

st.title("📊 Agent 效能分析儀表板")

# 載入執行日誌
logs = load_agent_logs()

# KPI 卡片
col1, col2, col3, col4 = st.columns(4)
with col1:
    st.metric("總執行次數", f"{len(logs):,}")
with col2:
    st.metric("總成本", f"${logs['cost'].sum():.2f}")
with col3:
    avg_duration = logs['duration'].mean()
    st.metric("平均執行時間", f"{avg_duration:.1f}s")
with col4:
    success_rate = (logs['success'].sum() / len(logs)) * 100
    st.metric("成功率", f"{success_rate:.1f}%")

# Agent 使用排行
st.subheader("📈 Agent 使用排行")
agent_usage = logs.groupby('agent').agg({
    'id': 'count',
    'cost': 'sum',
    'duration': 'mean'
}).rename(columns={'id': 'executions'})

fig = px.bar(
    agent_usage.reset_index(),
    x='agent',
    y='executions',
    color='cost',
    title='各 Agent 執行次數與成本'
)
st.plotly_chart(fig)

# 成本趨勢
st.subheader("💰 成本趨勢")
daily_cost = logs.groupby(
    logs['timestamp'].dt.date
)['cost'].sum()

fig = px.line(daily_cost, title='每日成本趨勢')
st.plotly_chart(fig)

# 失敗分析
st.subheader("🐛 失敗分析")
failed = logs[logs['success'] == False]
if len(failed) > 0:
    error_types = failed.groupby('error_type').size()
    fig = px.pie(
        values=error_types.values,
        names=error_types.index,
        title='錯誤類型分布'
    )
    st.plotly_chart(fig)
```

**預期效益**：
- 📊 數據驅動決策
- 💰 成本優化
- 🎯 效能瓶頸識別

---

### 🟢 16. A/B 測試框架（Agent 版本）

**現況問題**：
- Agent 優化無法量化效果
- 新版本 Agent 無法安全測試
- 無法比較不同 Prompt 策略

**建議方案**：
```python
# utils/ab_testing.py
class AgentABTesting:
    """Agent A/B 測試框架"""

    def __init__(self):
        self.experiments = {}

    def create_experiment(self, name, agent_a, agent_b, traffic_split=0.5):
        """創建 A/B 測試實驗"""
        self.experiments[name] = {
            'agent_a': agent_a,
            'agent_b': agent_b,
            'traffic_split': traffic_split,
            'results': {'a': [], 'b': []}
        }

    def run(self, experiment_name, user_id, *args, **kwargs):
        """執行測試（根據用戶分組）"""
        exp = self.experiments[experiment_name]

        # 根據 user_id hash 分組
        import hashlib
        group = 'a' if int(hashlib.md5(str(user_id).encode()).hexdigest(), 16) % 100 < exp['traffic_split'] * 100 else 'b'

        agent = exp[f'agent_{group}']
        result = agent.run(*args, **kwargs)

        # 記錄結果
        exp['results'][group].append({
            'user_id': user_id,
            'result': result,
            'timestamp': datetime.now()
        })

        return result

    def analyze_results(self, experiment_name):
        """分析實驗結果"""
        exp = self.experiments[experiment_name]

        # 計算統計差異
        from scipy import stats

        a_scores = [r['score'] for r in exp['results']['a']]
        b_scores = [r['score'] for r in exp['results']['b']]

        t_stat, p_value = stats.ttest_ind(a_scores, b_scores)

        return {
            'group_a_avg': np.mean(a_scores),
            'group_b_avg': np.mean(b_scores),
            'p_value': p_value,
            'significant': p_value < 0.05
        }

# 使用範例
ab_test = AgentABTesting()

# 測試新舊 Prompt
agent_old = CopywritingAgent(prompt_version='v1')
agent_new = CopywritingAgent(prompt_version='v2')

ab_test.create_experiment('copywriting_prompt', agent_old, agent_new)

# 用戶使用時自動分組
result = ab_test.run('copywriting_prompt', user_id=st.session_state.get('user_id'), ...)

# 分析結果
if st.button("📊 查看實驗結果"):
    analysis = ab_test.analyze_results('copywriting_prompt')
    st.write(analysis)
```

**預期效益**：
- 🧪 科學化優化
- 📈 持續改進
- 🎯 風險可控

---

### 🟢 17. 成本歸因與優化建議

**現況問題**：
- 不知道成本花在哪裡
- 無法識別浪費
- 缺乏優化方向

**建議方案**：
```python
# utils/cost_analyzer.py
class CostAnalyzer:
    """成本分析器"""

    def analyze_cost_breakdown(self, logs):
        """成本拆解分析"""
        breakdown = {
            'by_agent': logs.groupby('agent')['cost'].sum(),
            'by_model': logs.groupby('model')['cost'].sum(),
            'by_feature': logs.groupby('feature')['cost'].sum(),
            'by_user': logs.groupby('user_id')['cost'].sum()
        }
        return breakdown

    def identify_optimization_opportunities(self, logs):
        """識別優化機會"""
        opportunities = []

        # 1. 高頻低價值查詢
        freq_low_value = logs.groupby('query_hash').agg({
            'cost': 'sum',
            'user_satisfaction': 'mean'
        })
        wasteful = freq_low_value[
            (freq_low_value['cost'] > 10) &
            (freq_low_value['user_satisfaction'] < 3)
        ]

        if len(wasteful) > 0:
            opportunities.append({
                'type': '高成本低滿意度查詢',
                'impact': 'high',
                'suggestion': f'優化這 {len(wasteful)} 個查詢的 Prompt 或模型選擇',
                'potential_savings': wasteful['cost'].sum() * 0.6
            })

        # 2. 可快取但未快取
        cacheable = logs[logs['cache_hit'] == False]
        duplicate_queries = cacheable.groupby('query_hash').size()
        duplicates = duplicate_queries[duplicate_queries > 1]

        if len(duplicates) > 0:
            potential_savings = logs[
                logs['query_hash'].isin(duplicates.index)
            ]['cost'].sum() * 0.8

            opportunities.append({
                'type': '重複查詢未快取',
                'impact': 'high',
                'suggestion': '啟用查詢快取機制',
                'potential_savings': potential_savings
            })

        # 3. 過度使用高價模型
        expensive_model_usage = logs[logs['model'].str.contains('gpt-4')]
        if len(expensive_model_usage) > len(logs) * 0.3:
            opportunities.append({
                'type': '高價模型使用過多',
                'impact': 'medium',
                'suggestion': '評估是否可使用 gpt-5-nano 替代部分查詢',
                'potential_savings': expensive_model_usage['cost'].sum() * 0.5
            })

        return opportunities

    def generate_optimization_report(self, logs):
        """生成優化報告"""
        breakdown = self.analyze_cost_breakdown(logs)
        opportunities = self.identify_optimization_opportunities(logs)

        total_potential_savings = sum(o['potential_savings'] for o in opportunities)

        return {
            'current_monthly_cost': logs['cost'].sum(),
            'breakdown': breakdown,
            'optimization_opportunities': opportunities,
            'total_potential_savings': total_potential_savings,
            'savings_percentage': (total_potential_savings / logs['cost'].sum()) * 100
        }

# 在儀表板中使用
analyzer = CostAnalyzer()
report = analyzer.generate_optimization_report(logs)

st.title("💰 成本優化報告")

st.metric(
    "當前月度成本",
    f"${report['current_monthly_cost']:.2f}",
    delta=f"-${report['total_potential_savings']:.2f} 潛在節省"
)

st.subheader("🎯 優化機會")
for opp in report['optimization_opportunities']:
    with st.expander(f"{opp['type']} - 潛在節省 ${opp['potential_savings']:.2f}"):
        st.write(f"**影響等級**: {opp['impact']}")
        st.write(f"**建議**: {opp['suggestion']}")
```

**預期效益**：
- 💰 成本節省 30-50%
- 📊 透明化支出
- 🎯 精準優化

---

## 📝 實施優先級建議

### 🔴 立即實施（第1週）

1. **統一錯誤處理與重試機制** - 穩定性最重要
2. **日誌與監控系統** - 了解系統運行狀況
3. **敏感資料處理** - 安全性不能妥協
4. **Agent 結果快取** - 立即節省成本

**預期效益**: 穩定性提升 80%，成本降低 40%

### 🟡 近期實施（第2-4週）

5. **批次處理與並行執行** - 效能提升
6. **即時進度與取消功能** - 用戶體驗
7. **Agent 執行歷史** - 便利性
8. **自動化測試框架** - 品質保證
9. **輸入驗證** - 安全性

**預期效益**: 速度提升 2-3倍，用戶滿意度提升

### 🟢 長期規劃（第2-3個月）

10. **Agent 間協作工作流** - 功能突破
11. **智能模型選擇** - 成本優化
12. **個人化設定** - 差異化
13. **匯出分享功能** - 商業價值
14. **效能分析儀表板** - 數據驅動
15. **A/B 測試框架** - 持續優化
16. **成本分析** - 精細化管理
17. **API Key 輪替** - 容錯性

**預期效益**: 成為業界領先的 AI 廣告平台

---

## 🎯 總結

實施這 17 項優化後，系統將獲得：

### 技術指標

- ⚡ **效能提升**: 2-5倍
- 💰 **成本降低**: 30-50%
- 🛡️ **穩定性**: 99%+
- 🐛 **錯誤率**: <1%

### 商業價值

- 😊 **用戶滿意度**: 大幅提升
- 🚀 **功能豐富度**: 業界領先
- 💼 **商業化能力**: 具備付費產品水準
- 🎯 **競爭力**: 市場獨特性

### 開發效率

- 🔧 **維護成本**: 降低 50%
- 🧪 **測試覆蓋**: 80%+
- 📊 **可觀測性**: 完整透明
- 🚀 **迭代速度**: 提升 3倍

---

**建議行動**：
1. 先實施 🔴 高優先級項目（1-2週）
2. 觀察效果後推進 🟡 中優先級（2-4週）
3. 穩定後逐步加入 🟢 長期功能

**需要資源**：
- 開發時間: 20-40 小時（高優先級）
- 第三方服務: 可選（監控、加密等）
- 測試環境: 建議建立

---

*文件版本: 1.0*
*建議由: AI 系統分析*
*最後更新: 2025-10-06*
