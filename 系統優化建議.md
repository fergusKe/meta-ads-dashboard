# ç³»çµ±å„ªåŒ–å»ºè­°å ±å‘Š

> åŸºæ–¼å…¨é¢åˆ†æçš„ 17 é …å„ªåŒ–å»ºè­°ï¼Œè®“ç³»çµ±æ›´å¼·å¤§ã€æ›´ç©©å®šã€æ›´æ˜“ç”¨

## âœ… å¯¦ä½œé€²åº¦
- Agent å¿«å–ç³»çµ±ï¼š`utils/cache_manager.py`ã€`pages/27_ğŸ—„ï¸_å¿«å–ç®¡ç†.py`
- çµ±ä¸€éŒ¯èª¤è™•ç†ï¼š`utils/error_handler.py` å¥—ç”¨è‡³ Copywriting/Optimization ç­‰æ ¸å¿ƒ Agent
- æ™ºèƒ½æ¨¡å‹é¸æ“‡ï¼š`utils/model_selector.py` èˆ‡å€‹äººåŒ–è¨­å®š `pages/31_âš™ï¸_å€‹äººåŒ–åå¥½.py`
- å¤š Key è¼ªæ›¿èˆ‡æˆæœ¬ç›£æ§ï¼š`utils/api_keys.py`ã€`utils/llm_service.py`ã€`pages/28_ğŸ“Š_æ•ˆèƒ½èˆ‡æˆæœ¬å„€è¡¨æ¿.py`
- åŸ·è¡Œæ­·å²èˆ‡åŒ¯å‡ºï¼š`utils/history_manager.py`ã€`pages/30_ğŸ“œ_AgentåŸ·è¡Œæ­·å².py`
- A/B æ¸¬è©¦æ¡†æ¶ï¼š`utils/experiments.py`ã€`pages/29_ğŸ§ª_A_B_æ¸¬è©¦æ§åˆ¶å°.py`
- å…¶ä»–å·¥å…·ï¼š`utils/progress.py`ã€`utils/security.py`ã€`utils/exporter.py` ç­‰


**åˆ†ææ—¥æœŸ**ï¼š2025-10-06
**ç•¶å‰ç‰ˆæœ¬**ï¼š3.0
**ç³»çµ±è¦æ¨¡**ï¼š17 å€‹ Agent + 25 å€‹é é¢ + 11,729 è¡Œç¨‹å¼ç¢¼

---

## ğŸ¯ å„ªå…ˆç´šåˆ†é¡

- ğŸ”´ **é«˜å„ªå…ˆç´š**ï¼ˆå»ºè­°ç«‹å³å¯¦æ–½ï¼‰- ç›´æ¥å½±éŸ¿ç©©å®šæ€§èˆ‡ç”¨æˆ¶é«”é©—
- ğŸŸ¡ **ä¸­å„ªå…ˆç´š**ï¼ˆå»ºè­°è¿‘æœŸå¯¦æ–½ï¼‰- æå‡æ•ˆèƒ½èˆ‡é–‹ç™¼æ•ˆç‡
- ğŸŸ¢ **ä½å„ªå…ˆç´š**ï¼ˆé•·æœŸè¦åŠƒï¼‰- å¢å¼·åŠŸèƒ½èˆ‡æ“´å±•æ€§

---

## ğŸ“Š Category 1ï¼šæ•ˆèƒ½èˆ‡æˆæœ¬å„ªåŒ–

### ğŸ”´ 1. Agent çµæœå¿«å–æ©Ÿåˆ¶

**ç¾æ³å•é¡Œ**ï¼š
- æ¯æ¬¡ç”Ÿæˆéƒ½é‡æ–°å‘¼å« APIï¼Œæˆæœ¬é«˜ã€é€Ÿåº¦æ…¢
- ç›¸åŒåƒæ•¸çš„è«‹æ±‚é‡è¤‡è¨ˆç®—
- ç„¡å¿«å–å°è‡´ç”¨æˆ¶ç­‰å¾…æ™‚é–“é•·

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# utils/agents/cache_manager.py
import hashlib
import json
from functools import wraps
from datetime import datetime, timedelta

class AgentCache:
    """Agent çµæœå¿«å–ç®¡ç†"""

    def __init__(self, ttl_seconds=3600):
        self.cache = {}
        self.ttl = ttl_seconds

    def get_cache_key(self, agent_name, params):
        """ç”Ÿæˆå¿«å– key"""
        content = f"{agent_name}:{json.dumps(params, sort_keys=True)}"
        return hashlib.md5(content.encode()).hexdigest()

    def get(self, key):
        """ç²å–å¿«å–"""
        if key in self.cache:
            result, timestamp = self.cache[key]
            if datetime.now() - timestamp < timedelta(seconds=self.ttl):
                return result
            else:
                del self.cache[key]
        return None

    def set(self, key, value):
        """è¨­å®šå¿«å–"""
        self.cache[key] = (value, datetime.now())

# åœ¨æ¯å€‹ Agent ä¸­ä½¿ç”¨
def cache_agent_result(cache_key_params):
    def decorator(func):
        @wraps(func)
        async def wrapper(self, *args, **kwargs):
            cache = st.session_state.get('agent_cache')
            if not cache:
                cache = AgentCache(ttl_seconds=3600)
                st.session_state['agent_cache'] = cache

            key = cache.get_cache_key(
                self.__class__.__name__,
                cache_key_params(args, kwargs)
            )

            cached = cache.get(key)
            if cached:
                st.info("âœ¨ ä½¿ç”¨å¿«å–çµæœï¼ˆç¯€çœæˆæœ¬ï¼‰")
                return cached

            result = await func(self, *args, **kwargs)
            cache.set(key, result)
            return result
        return wrapper
    return decorator
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ’° ç¯€çœ API æˆæœ¬ 40-60%
- âš¡ ç›¸åŒæŸ¥è©¢éŸ¿æ‡‰é€Ÿåº¦æå‡ 10-100 å€
- ğŸ˜Š ç”¨æˆ¶é«”é©—å¤§å¹…æå‡

---

### ğŸŸ¡ 2. æ‰¹æ¬¡è™•ç†èˆ‡ä¸¦è¡ŒåŸ·è¡Œ

**ç¾æ³å•é¡Œ**ï¼š
- Agent å·¥å…·ä¸²è¡ŒåŸ·è¡Œï¼Œé€Ÿåº¦æ…¢
- å¤šå€‹ç¨ç«‹ Agent æœªä¸¦è¡Œè™•ç†
- æ•¸æ“šè¼‰å…¥ç„¡æ‰¹æ¬¡å„ªåŒ–

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
import asyncio

# åœ¨ Agent ä¸­ä¸¦è¡ŒåŸ·è¡Œå·¥å…·
async def parallel_tools_execution(self, tools_to_run):
    """ä¸¦è¡ŒåŸ·è¡Œå¤šå€‹å·¥å…·"""
    tasks = [tool() for tool in tools_to_run]
    results = await asyncio.gather(*tasks, return_exceptions=True)
    return results

# é é¢ä¸­ä¸¦è¡ŒåŸ·è¡Œå¤šå€‹ Agent
async def run_multiple_agents():
    """ä¸¦è¡ŒåŸ·è¡Œå¤šå€‹ Agent"""
    agent1 = CopywritingAgent()
    agent2 = ImagePromptAgent()

    results = await asyncio.gather(
        agent1.generate_copy(...),
        agent2.generate_prompts(...),
        return_exceptions=True
    )
    return results
```

**é æœŸæ•ˆç›Š**ï¼š
- âš¡ å¤š Agent é é¢é€Ÿåº¦æå‡ 2-3 å€
- ğŸ¯ æ›´å¥½çš„è³‡æºåˆ©ç”¨ç‡

---

### ğŸŸ¢ 3. æ™ºèƒ½æ¨¡å‹é¸æ“‡

**ç¾æ³å•é¡Œ**ï¼š
- æ‰€æœ‰ Agent çµ±ä¸€ä½¿ç”¨ gpt-5-nano
- æœªæ ¹æ“šä»»å‹™è¤‡é›œåº¦é¸æ“‡æ¨¡å‹
- ç°¡å–®ä»»å‹™å¯ç”¨æ›´ä¾¿å®œæ¨¡å‹ï¼Œè¤‡é›œä»»å‹™éœ€è¦æ›´å¼·æ¨¡å‹

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
class ModelSelector:
    """æ ¹æ“šä»»å‹™è¤‡é›œåº¦é¸æ“‡æ¨¡å‹"""

    MODELS = {
        'simple': 'gpt-5-nano',      # ç°¡å–®ä»»å‹™
        'medium': 'gpt-4o-mini',     # ä¸­ç­‰è¤‡é›œåº¦
        'complex': 'gpt-4o',         # è¤‡é›œä»»å‹™
        'vision': 'gemini-2.5-flash-image'  # åœ–ç‰‡ç›¸é—œ
    }

    @staticmethod
    def select_model(task_type, complexity='medium'):
        """é¸æ“‡åˆé©æ¨¡å‹"""
        if task_type == 'vision':
            return ModelSelector.MODELS['vision']
        return ModelSelector.MODELS.get(complexity, 'gpt-5-nano')

# åœ¨ Agent ä¸­ä½¿ç”¨
class DynamicAgent:
    def __init__(self, task_complexity='medium'):
        model = ModelSelector.select_model('text', task_complexity)
        self.agent = Agent(f'openai:{model}', ...)
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ’° æˆæœ¬å„ªåŒ– 20-30%
- ğŸ“ˆ è¤‡é›œä»»å‹™å“è³ªæå‡

---

## ğŸ›¡ï¸ Category 2ï¼šç©©å®šæ€§èˆ‡éŒ¯èª¤è™•ç†

### ğŸ”´ 4. çµ±ä¸€éŒ¯èª¤è™•ç†èˆ‡é‡è©¦æ©Ÿåˆ¶

**ç¾æ³å•é¡Œ**ï¼š
- å„ Agent éŒ¯èª¤è™•ç†ä¸ä¸€è‡´
- API å¤±æ•—ç„¡è‡ªå‹•é‡è©¦
- éŒ¯èª¤è¨Šæ¯å°ç”¨æˆ¶ä¸å‹å–„

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# utils/error_handler.py
from functools import wraps
import time

class AgentErrorHandler:
    """çµ±ä¸€éŒ¯èª¤è™•ç†"""

    @staticmethod
    def handle_errors(max_retries=3, backoff=2):
        def decorator(func):
            @wraps(func)
            async def wrapper(*args, **kwargs):
                for attempt in range(max_retries):
                    try:
                        return await func(*args, **kwargs)
                    except openai.RateLimitError as e:
                        if attempt < max_retries - 1:
                            wait_time = backoff ** attempt
                            st.warning(f"â³ API é…é¡é™åˆ¶ï¼Œ{wait_time}ç§’å¾Œé‡è©¦...")
                            time.sleep(wait_time)
                        else:
                            st.error("âŒ API é…é¡å·²é”ä¸Šé™ï¼Œè«‹ç¨å¾Œå†è©¦")
                            raise
                    except openai.APIError as e:
                        st.error(f"âŒ API éŒ¯èª¤ï¼š{str(e)}")
                        raise
                    except Exception as e:
                        st.error(f"âŒ æœªé æœŸéŒ¯èª¤ï¼š{str(e)}")
                        with st.expander("ğŸ” è©³ç´°éŒ¯èª¤è³‡è¨Š"):
                            st.code(traceback.format_exc())
                        raise
            return wrapper
        return decorator

# åœ¨æ‰€æœ‰ Agent çš„åŸ·è¡Œæ–¹æ³•åŠ ä¸Šè£é£¾å™¨
@AgentErrorHandler.handle_errors(max_retries=3)
async def generate_copy(self, ...):
    ...
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ›¡ï¸ ç©©å®šæ€§æå‡ 80%
- ğŸ˜Š ç”¨æˆ¶é«”é©—æ›´å¥½
- ğŸ› å•é¡Œæ›´å®¹æ˜“å®šä½

---

### ğŸ”´ 5. æ—¥èªŒèˆ‡ç›£æ§ç³»çµ±

**ç¾æ³å•é¡Œ**ï¼š
- ç„¡ç³»çµ±åŒ–æ—¥èªŒè¨˜éŒ„
- ç„¡æ³•è¿½è¹¤ Agent åŸ·è¡Œç‹€æ³
- ç„¡æ³•åˆ†æå¤±æ•—åŸå› 

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# utils/logger.py
import logging
from datetime import datetime
import json

class AgentLogger:
    """Agent æ—¥èªŒç³»çµ±"""

    def __init__(self, log_file="logs/agent_execution.log"):
        self.logger = logging.getLogger('AgentLogger')
        self.logger.setLevel(logging.INFO)

        # æª”æ¡ˆè™•ç†å™¨
        fh = logging.FileHandler(log_file)
        fh.setLevel(logging.INFO)

        # æ ¼å¼åŒ–
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        fh.setFormatter(formatter)
        self.logger.addHandler(fh)

    def log_agent_execution(self, agent_name, params, result, duration):
        """è¨˜éŒ„ Agent åŸ·è¡Œ"""
        log_data = {
            'timestamp': datetime.now().isoformat(),
            'agent': agent_name,
            'params': params,
            'success': result is not None,
            'duration_seconds': duration,
            'tokens_used': getattr(result, 'usage', None)
        }
        self.logger.info(json.dumps(log_data, ensure_ascii=False))

    def log_error(self, agent_name, error, params):
        """è¨˜éŒ„éŒ¯èª¤"""
        self.logger.error(f"Agent: {agent_name}, Error: {str(error)}, Params: {params}")

# æ•´åˆ Pydantic AI çš„ Logfire
import logfire

logfire.configure()

# åœ¨ Agent ä¸­å•Ÿç”¨
class MonitoredAgent:
    def __init__(self):
        logfire.instrument_pydantic_ai()
        self.agent = Agent(...)
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ“Š å®Œæ•´åŸ·è¡Œè¨˜éŒ„
- ğŸ› å¿«é€Ÿå®šä½å•é¡Œ
- ğŸ“ˆ æˆæœ¬èˆ‡æ•ˆèƒ½åˆ†æ

---

### ğŸŸ¡ 6. API Key è¼ªæ›¿èˆ‡é…é¡ç®¡ç†

**ç¾æ³å•é¡Œ**ï¼š
- å–®ä¸€ API Keyï¼Œé…é¡ç”¨å®Œå°±å¡ä½
- ç„¡é…é¡ç›£æ§
- ç„¡æˆæœ¬æ§åˆ¶

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# utils/api_manager.py
class APIKeyManager:
    """API Key ç®¡ç†èˆ‡è¼ªæ›¿"""

    def __init__(self):
        self.keys = {
            'primary': os.getenv('OPENAI_API_KEY'),
            'backup1': os.getenv('OPENAI_API_KEY_BACKUP1'),
            'backup2': os.getenv('OPENAI_API_KEY_BACKUP2'),
        }
        self.current_key = 'primary'
        self.usage = {key: 0 for key in self.keys}
        self.daily_limit = 100  # USD

    def get_key(self):
        """å–å¾—å¯ç”¨çš„ Key"""
        if self.usage[self.current_key] >= self.daily_limit:
            self._switch_key()
        return self.keys[self.current_key]

    def _switch_key(self):
        """åˆ‡æ›åˆ°å‚™ç”¨ Key"""
        for key_name in ['backup1', 'backup2']:
            if self.usage[key_name] < self.daily_limit:
                self.current_key = key_name
                st.info(f"ğŸ”„ åˆ‡æ›åˆ°å‚™ç”¨ API Key: {key_name}")
                return
        st.error("âŒ æ‰€æœ‰ API Key éƒ½å·²é”é…é¡ä¸Šé™")

    def record_usage(self, cost):
        """è¨˜éŒ„ä½¿ç”¨é‡"""
        self.usage[self.current_key] += cost
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ”„ è‡ªå‹•å®¹éŒ¯åˆ‡æ›
- ğŸ’° æˆæœ¬å¯æ§
- ğŸ“Š ç”¨é‡é€æ˜

---

## ğŸš€ Category 3ï¼šåŠŸèƒ½å¢å¼·

### ğŸŸ¡ 7. Agent åŸ·è¡Œæ­·å²èˆ‡æ¯”è¼ƒ

**ç¾æ³å•é¡Œ**ï¼š
- ç„¡æ³•æŸ¥çœ‹æ­·å²ç”Ÿæˆçµæœ
- ç„¡æ³•æ¯”è¼ƒä¸åŒç‰ˆæœ¬
- ç„¡æ³•è¿½è¹¤å„ªåŒ–æ•ˆæœ

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# utils/agent_history.py
class AgentHistory:
    """Agent åŸ·è¡Œæ­·å²ç®¡ç†"""

    def __init__(self):
        self.history_file = "data/agent_history.json"

    def save_result(self, agent_name, params, result):
        """å„²å­˜çµæœ"""
        history = self._load_history()

        entry = {
            'timestamp': datetime.now().isoformat(),
            'agent': agent_name,
            'params': params,
            'result': result.model_dump() if hasattr(result, 'model_dump') else str(result),
            'id': hashlib.md5(f"{agent_name}{datetime.now()}".encode()).hexdigest()[:8]
        }

        history.append(entry)
        self._save_history(history)
        return entry['id']

    def get_history(self, agent_name, limit=10):
        """å–å¾—æ­·å²è¨˜éŒ„"""
        history = self._load_history()
        filtered = [h for h in history if h['agent'] == agent_name]
        return filtered[-limit:]

    def compare_results(self, result_id1, result_id2):
        """æ¯”è¼ƒå…©å€‹çµæœ"""
        history = self._load_history()
        r1 = next(h for h in history if h['id'] == result_id1)
        r2 = next(h for h in history if h['id'] == result_id2)
        return {'result1': r1, 'result2': r2, 'diff': self._calculate_diff(r1, r2)}

# åœ¨é é¢ä¸­ä½¿ç”¨
history = AgentHistory()

# å„²å­˜çµæœ
result_id = history.save_result('CopywritingAgent', params, result)

# é¡¯ç¤ºæ­·å²
with st.expander("ğŸ“š æŸ¥çœ‹æ­·å²ç”Ÿæˆçµæœ"):
    past_results = history.get_history('CopywritingAgent', limit=5)
    for r in past_results:
        st.write(f"**{r['timestamp']}** - ID: {r['id']}")
        if st.button(f"è¼‰å…¥æ­¤çµæœ", key=r['id']):
            st.session_state['loaded_result'] = r['result']
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ“š çµæœå¯è¿½æº¯
- ğŸ”„ å¿«é€Ÿé‡ç”¨æ­·å²çµæœ
- ğŸ“Š A/B æ¸¬è©¦æ›´å®¹æ˜“

---

### ğŸŸ¡ 8. è‡ªå‹•åŒ–æ¸¬è©¦æ¡†æ¶

**ç¾æ³å•é¡Œ**ï¼š
- åªæœ‰ 1 å€‹æ¸¬è©¦æª”æ¡ˆ
- Agent ç„¡è‡ªå‹•åŒ–æ¸¬è©¦
- é‡æ§‹æ™‚ç„¡æ³•ä¿è­‰åŠŸèƒ½æ­£å¸¸

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# tests/test_agents.py
import pytest
from utils.agents import CopywritingAgent

class TestCopywritingAgent:
    """CopywritingAgent æ¸¬è©¦"""

    @pytest.fixture
    def agent(self):
        return CopywritingAgent()

    @pytest.mark.asyncio
    async def test_generate_copy_basic(self, agent):
        """æ¸¬è©¦åŸºæœ¬æ–‡æ¡ˆç”Ÿæˆ"""
        result = await agent.generate_copy(
            product_name="æ¸¬è©¦ç”¢å“",
            target_audience="25-35æ­²ä¸Šç­æ—",
            campaign_goal="æå‡å“ç‰ŒçŸ¥ååº¦",
            tone="å°ˆæ¥­"
        )

        assert len(result.variants) >= 3
        assert len(result.variants) <= 5
        assert result.strategy_explanation != ""
        assert len(result.ab_test_suggestions) > 0

    @pytest.mark.asyncio
    async def test_output_validation(self, agent):
        """æ¸¬è©¦ Pydantic é©—è­‰"""
        result = await agent.generate_copy(...)

        # é©—è­‰çµæ§‹å®Œæ•´æ€§
        for variant in result.variants:
            assert variant.headline != ""
            assert variant.primary_text != ""
            assert variant.cta != ""
            assert len(variant.headline) <= 100

# tests/test_integration.py
class TestIntegration:
    """æ•´åˆæ¸¬è©¦"""

    @pytest.mark.asyncio
    async def test_copywriting_to_image_flow(self):
        """æ¸¬è©¦æ–‡æ¡ˆç”Ÿæˆ -> åœ–ç‰‡ç”Ÿæˆæµç¨‹"""
        copywriting_agent = CopywritingAgent()
        image_agent = ImagePromptAgent()

        # ç”Ÿæˆæ–‡æ¡ˆ
        copy_result = await copywriting_agent.generate_copy(...)

        # ä½¿ç”¨æ–‡æ¡ˆç”Ÿæˆåœ–ç‰‡æç¤ºè©
        image_result = await image_agent.generate_prompts(
            copy_context=copy_result.variants[0].primary_text
        )

        assert image_result is not None
        assert len(image_result.variants) == 3

# è¨­å®š GitHub Actions
# .github/workflows/test.yml
name: Test
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.10'
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-asyncio
      - name: Run tests
        run: pytest tests/ -v
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ›¡ï¸ é˜²æ­¢åŠŸèƒ½é€€åŒ–
- ğŸš€ é‡æ§‹æ›´æœ‰ä¿¡å¿ƒ
- ğŸ“Š ç¨‹å¼ç¢¼å“è³ªå¯é‡åŒ–

---

### ğŸŸ¢ 9. Agent é–“å”ä½œèˆ‡å·¥ä½œæµ

**ç¾æ³å•é¡Œ**ï¼š
- Agent å„è‡ªç¨ç«‹é‹ä½œ
- ç„¡æ³•ä¸²é€£å½¢æˆå·¥ä½œæµ
- éœ€æ‰‹å‹•åœ¨é é¢é–“åˆ‡æ›

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# utils/workflows/campaign_workflow.py
class CampaignCreationWorkflow:
    """å»£å‘Šæ´»å‹•å‰µå»ºå·¥ä½œæµ"""

    def __init__(self):
        self.strategy_agent = StrategyAgent()
        self.copywriting_agent = CopywritingAgent()
        self.image_agent = ImagePromptAgent()
        self.optimization_agent = OptimizationAgent()

    async def create_campaign(self, brief):
        """ä¸€éµå‰µå»ºå®Œæ•´å»£å‘Šæ´»å‹•"""

        # Step 1: ç­–ç•¥è¦åŠƒ
        strategy = await self.strategy_agent.plan_strategy(
            product=brief['product'],
            budget=brief['budget'],
            goal=brief['goal']
        )

        # Step 2: æ–‡æ¡ˆç”Ÿæˆï¼ˆåŸºæ–¼ç­–ç•¥ï¼‰
        copy_results = await self.copywriting_agent.generate_copy(
            target_audience=strategy.target_audience,
            tone=strategy.recommended_tone,
            key_messages=strategy.key_messages
        )

        # Step 3: åœ–ç‰‡æç¤ºè©ï¼ˆåŸºæ–¼æ–‡æ¡ˆï¼‰
        image_prompts = await self.image_agent.generate_prompts(
            copy_context=copy_results.variants[0].primary_text,
            style=strategy.visual_style
        )

        # Step 4: å„ªåŒ–å»ºè­°
        optimization = await self.optimization_agent.analyze(
            copy=copy_results,
            images=image_prompts,
            strategy=strategy
        )

        return {
            'strategy': strategy,
            'copy': copy_results,
            'images': image_prompts,
            'optimization': optimization
        }

# åœ¨æ–°é é¢ä½¿ç”¨
st.title("ğŸš€ ä¸€éµå‰µå»ºå»£å‘Šæ´»å‹•")

if st.button("é–‹å§‹å‰µå»º"):
    workflow = CampaignCreationWorkflow()

    with st.spinner("ğŸ¤– AI æ­£åœ¨å‰µå»ºå®Œæ•´å»£å‘Šæ´»å‹•..."):
        result = await workflow.create_campaign(brief)

    st.success("âœ… å»£å‘Šæ´»å‹•å‰µå»ºå®Œæˆï¼")

    # é¡¯ç¤ºæ‰€æœ‰çµæœ
    tabs = st.tabs(["ç­–ç•¥", "æ–‡æ¡ˆ", "åœ–ç‰‡", "å„ªåŒ–å»ºè­°"])
    with tabs[0]:
        st.write(result['strategy'])
    # ...
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸš€ æ•ˆç‡æå‡ 5-10 å€
- ğŸ¯ AI å”ä½œæ›´æ™ºèƒ½
- ğŸ˜Š ç”¨æˆ¶é«”é©—è³ªçš„é£›èº

---

## ğŸ“± Category 4ï¼šç”¨æˆ¶é«”é©—

### ğŸŸ¡ 10. å³æ™‚é€²åº¦èˆ‡å–æ¶ˆåŠŸèƒ½

**ç¾æ³å•é¡Œ**ï¼š
- Agent åŸ·è¡Œæ™‚é–“é•·ï¼Œç„¡é€²åº¦é¡¯ç¤º
- ç„¡æ³•ä¸­é€”å–æ¶ˆ
- ç”¨æˆ¶ä¸çŸ¥é“è¦ç­‰å¤šä¹…

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# åœ¨ Agent åŸ·è¡Œä¸­åŠ å…¥é€²åº¦å›å ±
class ProgressTracker:
    """é€²åº¦è¿½è¹¤"""

    def __init__(self, total_steps):
        self.total = total_steps
        self.current = 0
        self.placeholder = st.empty()

    def update(self, step_name):
        """æ›´æ–°é€²åº¦"""
        self.current += 1
        progress = self.current / self.total
        self.placeholder.progress(
            progress,
            text=f"æ­¥é©Ÿ {self.current}/{self.total}: {step_name}"
        )

    def complete(self):
        """å®Œæˆ"""
        self.placeholder.success("âœ… å®Œæˆï¼")

# åœ¨ Agent ä¸­ä½¿ç”¨
async def generate_copy_with_progress(self, ...):
    tracker = ProgressTracker(total_steps=5)

    tracker.update("è¼‰å…¥ RAG çŸ¥è­˜åº«")
    rag_data = await self._load_rag()

    tracker.update("åˆ†æå—çœ¾ç‰¹å¾µ")
    audience = await self._analyze_audience()

    tracker.update("ç”Ÿæˆæ–‡æ¡ˆè®Šé«”")
    variants = await self._generate_variants()

    tracker.update("Pydantic é©—è­‰")
    result = self._validate(variants)

    tracker.update("å¾Œè™•ç†èˆ‡å„ªåŒ–")
    final = self._post_process(result)

    tracker.complete()
    return final

# åŠ å…¥å–æ¶ˆæŒ‰éˆ•
cancel_button = st.button("âŒ å–æ¶ˆåŸ·è¡Œ")
if cancel_button:
    st.session_state['cancel_flag'] = True
    st.warning("â¸ï¸ æ­£åœ¨å–æ¶ˆ...")

# åœ¨ Agent åŸ·è¡Œéç¨‹æª¢æŸ¥
if st.session_state.get('cancel_flag'):
    st.session_state['cancel_flag'] = False
    raise CancelledException("ç”¨æˆ¶å–æ¶ˆåŸ·è¡Œ")
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ˜Š ç”¨æˆ¶ç„¦æ…®é™ä½
- ğŸ¯ å¯æ§æ€§æå‡
- â±ï¸ æ™‚é–“é æœŸæ›´æº–ç¢º

---

### ğŸŸ¡ 11. å€‹äººåŒ–è¨­å®šèˆ‡åå¥½

**ç¾æ³å•é¡Œ**ï¼š
- ç„¡æ³•å„²å­˜ç”¨æˆ¶åå¥½
- æ¯æ¬¡éƒ½è¦é‡æ–°è¼¸å…¥åƒæ•¸
- ç„¡å®¢è£½åŒ–é¸é …

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# utils/user_preferences.py
class UserPreferences:
    """ç”¨æˆ¶åå¥½ç®¡ç†"""

    def __init__(self):
        if 'user_prefs' not in st.session_state:
            st.session_state['user_prefs'] = self._load_defaults()

    def save_preference(self, category, key, value):
        """å„²å­˜åå¥½"""
        st.session_state['user_prefs'][category][key] = value
        self._persist_to_file()

    def get_preference(self, category, key, default=None):
        """å–å¾—åå¥½"""
        return st.session_state['user_prefs'].get(category, {}).get(key, default)

    def _load_defaults(self):
        return {
            'copywriting': {
                'default_tone': 'å°ˆæ¥­æº«æš–',
                'default_length': 'ä¸­ç­‰',
                'enable_rag': True
            },
            'image': {
                'default_style': 'ç¾ä»£ç°¡ç´„',
                'default_size': '1:1',
            },
            'general': {
                'theme': 'light',
                'show_debug': False,
                'auto_save_history': True
            }
        }

# åœ¨é é¢ä¸­ä½¿ç”¨
prefs = UserPreferences()

# ä½¿ç”¨å„²å­˜çš„åå¥½ä½œç‚ºé è¨­å€¼
tone = st.selectbox(
    "èªæ°£é¢¨æ ¼",
    ["å°ˆæ¥­æº«æš–", "æ´»æ½‘å¹´è¼•", "å…¸é›…å‚³çµ±"],
    index=["å°ˆæ¥­æº«æš–", "æ´»æ½‘å¹´è¼•", "å…¸é›…å‚³çµ±"].index(
        prefs.get_preference('copywriting', 'default_tone', 'å°ˆæ¥­æº«æš–')
    )
)

# å„²å­˜åå¥½
if st.button("ğŸ’¾ è¨˜ä½é€™äº›è¨­å®š"):
    prefs.save_preference('copywriting', 'default_tone', tone)
    st.success("âœ… è¨­å®šå·²å„²å­˜")
```

**é æœŸæ•ˆç›Š**ï¼š
- âš¡ æå‡æ“ä½œæ•ˆç‡
- ğŸ˜Š å€‹äººåŒ–é«”é©—
- ğŸ¯ æ¸›å°‘é‡è¤‡è¼¸å…¥

---

### ğŸŸ¢ 12. åŒ¯å‡ºèˆ‡åˆ†äº«åŠŸèƒ½

**ç¾æ³å•é¡Œ**ï¼š
- ç”Ÿæˆçµæœç„¡æ³•åŒ¯å‡º
- ç„¡æ³•åˆ†äº«çµ¦åœ˜éšŠæˆå“¡
- ç„¡æ³•æ•´åˆåˆ°å…¶ä»–å·¥å…·

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# utils/export_manager.py
class ExportManager:
    """åŒ¯å‡ºç®¡ç†"""

    def export_to_pdf(self, content, filename):
        """åŒ¯å‡ºç‚º PDF"""
        from reportlab.pdfgen import canvas
        # PDF ç”Ÿæˆé‚è¼¯
        pass

    def export_to_excel(self, data, filename):
        """åŒ¯å‡ºç‚º Excel"""
        df = pd.DataFrame(data)
        buffer = BytesIO()
        df.to_excel(buffer, index=False)
        return buffer.getvalue()

    def export_to_json(self, result):
        """åŒ¯å‡ºç‚º JSON"""
        return json.dumps(
            result.model_dump() if hasattr(result, 'model_dump') else result,
            ensure_ascii=False,
            indent=2
        )

    def create_share_link(self, result_id):
        """å‰µå»ºåˆ†äº«é€£çµ"""
        # ç”ŸæˆçŸ­ç¶²å€æˆ–åŠ å¯†é€£çµ
        return f"https://your-domain.com/share/{result_id}"

# åœ¨é é¢ä¸­ä½¿ç”¨
exporter = ExportManager()

col1, col2, col3 = st.columns(3)
with col1:
    if st.button("ğŸ“„ åŒ¯å‡º PDF"):
        pdf = exporter.export_to_pdf(result, "å»£å‘Šæ–‡æ¡ˆ.pdf")
        st.download_button("ä¸‹è¼‰ PDF", pdf, "å»£å‘Šæ–‡æ¡ˆ.pdf")

with col2:
    if st.button("ğŸ“Š åŒ¯å‡º Excel"):
        excel = exporter.export_to_excel(result, "å»£å‘Šæ–‡æ¡ˆ.xlsx")
        st.download_button("ä¸‹è¼‰ Excel", excel, "å»£å‘Šæ–‡æ¡ˆ.xlsx")

with col3:
    if st.button("ğŸ”— åˆ†äº«é€£çµ"):
        link = exporter.create_share_link(result_id)
        st.code(link)
        st.success("âœ… é€£çµå·²è¤‡è£½")
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ“¤ å”ä½œæ›´ä¾¿åˆ©
- ğŸ’¼ å•†æ¥­åƒ¹å€¼æå‡
- ğŸ”— æ•´åˆå…¶ä»–å·¥å…·

---

## ğŸ”’ Category 5ï¼šå®‰å…¨æ€§èˆ‡åˆè¦

### ğŸ”´ 13. æ•æ„Ÿè³‡æ–™è™•ç†

**ç¾æ³å•é¡Œ**ï¼š
- API Key ç›´æ¥å¯«åœ¨ .envï¼ˆå·²æš´éœ²åœ¨æ–‡ä»¶ä¸­ï¼‰
- ç„¡åŠ å¯†æ©Ÿåˆ¶
- æ­·å²è¨˜éŒ„å¯èƒ½åŒ…å«æ•æ„Ÿè³‡æ–™

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# utils/security.py
from cryptography.fernet import Fernet
import os

class SecureStorage:
    """å®‰å…¨å„²å­˜"""

    def __init__(self):
        # å¾ç’°å¢ƒè®Šæ•¸æˆ– Secrets Manager å–å¾—åŠ å¯†é‡‘é‘°
        key = os.getenv('ENCRYPTION_KEY') or Fernet.generate_key()
        self.cipher = Fernet(key)

    def encrypt(self, data):
        """åŠ å¯†"""
        return self.cipher.encrypt(data.encode()).decode()

    def decrypt(self, encrypted_data):
        """è§£å¯†"""
        return self.cipher.decrypt(encrypted_data.encode()).decode()

# å®‰å…¨å„²å­˜ API Key
secure = SecureStorage()
encrypted_key = secure.encrypt(os.getenv('OPENAI_API_KEY'))

# ä½¿ç”¨ Streamlit Secretsï¼ˆæ¨è–¦ï¼‰
# .streamlit/secrets.toml
# OPENAI_API_KEY = "sk-..."
# GEMINI_API_KEY = "AIza..."

# åœ¨ç¨‹å¼ä¸­ä½¿ç”¨
api_key = st.secrets["OPENAI_API_KEY"]
```

**å»ºè­°é…ç½®**ï¼š
```toml
# .streamlit/secrets.tomlï¼ˆä¸è¦æäº¤åˆ° Gitï¼‰
[openai]
api_key = "sk-..."
model = "gpt-5-nano"

[gemini]
api_key = "AIza..."
model = "gemini-2.5-flash-image"

[database]
connection_string = "..."
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ”’ å®‰å…¨æ€§å¤§å¹…æå‡
- ğŸ“‹ ç¬¦åˆè³‡æ–™ä¿è­·æ³•è¦
- ğŸ›¡ï¸ é˜²æ­¢é‡‘é‘°æ´©æ¼

---

### ğŸŸ¡ 14. è¼¸å…¥é©—è­‰èˆ‡æ¸…ç†

**ç¾æ³å•é¡Œ**ï¼š
- ç”¨æˆ¶è¼¸å…¥æœªé©—è­‰
- å¯èƒ½æœ‰æ³¨å…¥æ”»æ“Šé¢¨éšª
- ç„¡ç•°å¸¸è¼¸å…¥è™•ç†

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# utils/validators.py
import re

class InputValidator:
    """è¼¸å…¥é©—è­‰"""

    @staticmethod
    def validate_text_input(text, max_length=1000, allow_special_chars=True):
        """é©—è­‰æ–‡å­—è¼¸å…¥"""
        if not text or len(text.strip()) == 0:
            raise ValueError("è¼¸å…¥ä¸èƒ½ç‚ºç©º")

        if len(text) > max_length:
            raise ValueError(f"è¼¸å…¥é•·åº¦ä¸èƒ½è¶…é {max_length} å­—")

        if not allow_special_chars:
            if not re.match(r'^[\u4e00-\u9fa5a-zA-Z0-9\s]+$', text):
                raise ValueError("è¼¸å…¥åŒ…å«ä¸å…è¨±çš„ç‰¹æ®Šå­—å…ƒ")

        return text.strip()

    @staticmethod
    def sanitize_filename(filename):
        """æ¸…ç†æª”æ¡ˆåç¨±"""
        return re.sub(r'[^\w\s-]', '', filename).strip()

    @staticmethod
    def validate_url(url):
        """é©—è­‰ URL"""
        pattern = re.compile(
            r'^https?://'  # http:// or https://
            r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|'  # domain
            r'localhost|'  # localhost
            r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
            r'(?::\d+)?'  # optional port
            r'(?:/?|[/?]\S+)$', re.IGNORECASE)
        return pattern.match(url) is not None

# åœ¨é é¢ä¸­ä½¿ç”¨
validator = InputValidator()

try:
    product_name = validator.validate_text_input(
        st.text_input("ç”¢å“åç¨±"),
        max_length=100,
        allow_special_chars=False
    )
except ValueError as e:
    st.error(f"âŒ {str(e)}")
    st.stop()
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ›¡ï¸ é˜²æ­¢æƒ¡æ„è¼¸å…¥
- ğŸ“‹ è³‡æ–™å“è³ªæå‡
- ğŸ› æ¸›å°‘ç•°å¸¸éŒ¯èª¤

---

## ğŸ“Š Category 6ï¼šæ•¸æ“šèˆ‡åˆ†æ

### ğŸŸ¢ 15. Agent æ•ˆèƒ½åˆ†æå„€è¡¨æ¿

**ç¾æ³å•é¡Œ**ï¼š
- ç„¡æ³•äº†è§£å„ Agent çš„ä½¿ç”¨æƒ…æ³
- ç„¡æ³•åˆ†ææˆæœ¬èˆ‡æ•ˆèƒ½
- ç„¡æ•¸æ“šé©…å‹•çš„å„ªåŒ–æ±ºç­–

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# pages/26_ğŸ“Š_Agentæ•ˆèƒ½åˆ†æ.py
import streamlit as st
import pandas as pd
import plotly.express as px

st.title("ğŸ“Š Agent æ•ˆèƒ½åˆ†æå„€è¡¨æ¿")

# è¼‰å…¥åŸ·è¡Œæ—¥èªŒ
logs = load_agent_logs()

# KPI å¡ç‰‡
col1, col2, col3, col4 = st.columns(4)
with col1:
    st.metric("ç¸½åŸ·è¡Œæ¬¡æ•¸", f"{len(logs):,}")
with col2:
    st.metric("ç¸½æˆæœ¬", f"${logs['cost'].sum():.2f}")
with col3:
    avg_duration = logs['duration'].mean()
    st.metric("å¹³å‡åŸ·è¡Œæ™‚é–“", f"{avg_duration:.1f}s")
with col4:
    success_rate = (logs['success'].sum() / len(logs)) * 100
    st.metric("æˆåŠŸç‡", f"{success_rate:.1f}%")

# Agent ä½¿ç”¨æ’è¡Œ
st.subheader("ğŸ“ˆ Agent ä½¿ç”¨æ’è¡Œ")
agent_usage = logs.groupby('agent').agg({
    'id': 'count',
    'cost': 'sum',
    'duration': 'mean'
}).rename(columns={'id': 'executions'})

fig = px.bar(
    agent_usage.reset_index(),
    x='agent',
    y='executions',
    color='cost',
    title='å„ Agent åŸ·è¡Œæ¬¡æ•¸èˆ‡æˆæœ¬'
)
st.plotly_chart(fig)

# æˆæœ¬è¶¨å‹¢
st.subheader("ğŸ’° æˆæœ¬è¶¨å‹¢")
daily_cost = logs.groupby(
    logs['timestamp'].dt.date
)['cost'].sum()

fig = px.line(daily_cost, title='æ¯æ—¥æˆæœ¬è¶¨å‹¢')
st.plotly_chart(fig)

# å¤±æ•—åˆ†æ
st.subheader("ğŸ› å¤±æ•—åˆ†æ")
failed = logs[logs['success'] == False]
if len(failed) > 0:
    error_types = failed.groupby('error_type').size()
    fig = px.pie(
        values=error_types.values,
        names=error_types.index,
        title='éŒ¯èª¤é¡å‹åˆ†å¸ƒ'
    )
    st.plotly_chart(fig)
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ“Š æ•¸æ“šé©…å‹•æ±ºç­–
- ğŸ’° æˆæœ¬å„ªåŒ–
- ğŸ¯ æ•ˆèƒ½ç“¶é ¸è­˜åˆ¥

---

### ğŸŸ¢ 16. A/B æ¸¬è©¦æ¡†æ¶ï¼ˆAgent ç‰ˆæœ¬ï¼‰

**ç¾æ³å•é¡Œ**ï¼š
- Agent å„ªåŒ–ç„¡æ³•é‡åŒ–æ•ˆæœ
- æ–°ç‰ˆæœ¬ Agent ç„¡æ³•å®‰å…¨æ¸¬è©¦
- ç„¡æ³•æ¯”è¼ƒä¸åŒ Prompt ç­–ç•¥

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# utils/ab_testing.py
class AgentABTesting:
    """Agent A/B æ¸¬è©¦æ¡†æ¶"""

    def __init__(self):
        self.experiments = {}

    def create_experiment(self, name, agent_a, agent_b, traffic_split=0.5):
        """å‰µå»º A/B æ¸¬è©¦å¯¦é©—"""
        self.experiments[name] = {
            'agent_a': agent_a,
            'agent_b': agent_b,
            'traffic_split': traffic_split,
            'results': {'a': [], 'b': []}
        }

    def run(self, experiment_name, user_id, *args, **kwargs):
        """åŸ·è¡Œæ¸¬è©¦ï¼ˆæ ¹æ“šç”¨æˆ¶åˆ†çµ„ï¼‰"""
        exp = self.experiments[experiment_name]

        # æ ¹æ“š user_id hash åˆ†çµ„
        import hashlib
        group = 'a' if int(hashlib.md5(str(user_id).encode()).hexdigest(), 16) % 100 < exp['traffic_split'] * 100 else 'b'

        agent = exp[f'agent_{group}']
        result = agent.run(*args, **kwargs)

        # è¨˜éŒ„çµæœ
        exp['results'][group].append({
            'user_id': user_id,
            'result': result,
            'timestamp': datetime.now()
        })

        return result

    def analyze_results(self, experiment_name):
        """åˆ†æå¯¦é©—çµæœ"""
        exp = self.experiments[experiment_name]

        # è¨ˆç®—çµ±è¨ˆå·®ç•°
        from scipy import stats

        a_scores = [r['score'] for r in exp['results']['a']]
        b_scores = [r['score'] for r in exp['results']['b']]

        t_stat, p_value = stats.ttest_ind(a_scores, b_scores)

        return {
            'group_a_avg': np.mean(a_scores),
            'group_b_avg': np.mean(b_scores),
            'p_value': p_value,
            'significant': p_value < 0.05
        }

# ä½¿ç”¨ç¯„ä¾‹
ab_test = AgentABTesting()

# æ¸¬è©¦æ–°èˆŠ Prompt
agent_old = CopywritingAgent(prompt_version='v1')
agent_new = CopywritingAgent(prompt_version='v2')

ab_test.create_experiment('copywriting_prompt', agent_old, agent_new)

# ç”¨æˆ¶ä½¿ç”¨æ™‚è‡ªå‹•åˆ†çµ„
result = ab_test.run('copywriting_prompt', user_id=st.session_state.get('user_id'), ...)

# åˆ†æçµæœ
if st.button("ğŸ“Š æŸ¥çœ‹å¯¦é©—çµæœ"):
    analysis = ab_test.analyze_results('copywriting_prompt')
    st.write(analysis)
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ§ª ç§‘å­¸åŒ–å„ªåŒ–
- ğŸ“ˆ æŒçºŒæ”¹é€²
- ğŸ¯ é¢¨éšªå¯æ§

---

### ğŸŸ¢ 17. æˆæœ¬æ­¸å› èˆ‡å„ªåŒ–å»ºè­°

**ç¾æ³å•é¡Œ**ï¼š
- ä¸çŸ¥é“æˆæœ¬èŠ±åœ¨å“ªè£¡
- ç„¡æ³•è­˜åˆ¥æµªè²»
- ç¼ºä¹å„ªåŒ–æ–¹å‘

**å»ºè­°æ–¹æ¡ˆ**ï¼š
```python
# utils/cost_analyzer.py
class CostAnalyzer:
    """æˆæœ¬åˆ†æå™¨"""

    def analyze_cost_breakdown(self, logs):
        """æˆæœ¬æ‹†è§£åˆ†æ"""
        breakdown = {
            'by_agent': logs.groupby('agent')['cost'].sum(),
            'by_model': logs.groupby('model')['cost'].sum(),
            'by_feature': logs.groupby('feature')['cost'].sum(),
            'by_user': logs.groupby('user_id')['cost'].sum()
        }
        return breakdown

    def identify_optimization_opportunities(self, logs):
        """è­˜åˆ¥å„ªåŒ–æ©Ÿæœƒ"""
        opportunities = []

        # 1. é«˜é »ä½åƒ¹å€¼æŸ¥è©¢
        freq_low_value = logs.groupby('query_hash').agg({
            'cost': 'sum',
            'user_satisfaction': 'mean'
        })
        wasteful = freq_low_value[
            (freq_low_value['cost'] > 10) &
            (freq_low_value['user_satisfaction'] < 3)
        ]

        if len(wasteful) > 0:
            opportunities.append({
                'type': 'é«˜æˆæœ¬ä½æ»¿æ„åº¦æŸ¥è©¢',
                'impact': 'high',
                'suggestion': f'å„ªåŒ–é€™ {len(wasteful)} å€‹æŸ¥è©¢çš„ Prompt æˆ–æ¨¡å‹é¸æ“‡',
                'potential_savings': wasteful['cost'].sum() * 0.6
            })

        # 2. å¯å¿«å–ä½†æœªå¿«å–
        cacheable = logs[logs['cache_hit'] == False]
        duplicate_queries = cacheable.groupby('query_hash').size()
        duplicates = duplicate_queries[duplicate_queries > 1]

        if len(duplicates) > 0:
            potential_savings = logs[
                logs['query_hash'].isin(duplicates.index)
            ]['cost'].sum() * 0.8

            opportunities.append({
                'type': 'é‡è¤‡æŸ¥è©¢æœªå¿«å–',
                'impact': 'high',
                'suggestion': 'å•Ÿç”¨æŸ¥è©¢å¿«å–æ©Ÿåˆ¶',
                'potential_savings': potential_savings
            })

        # 3. éåº¦ä½¿ç”¨é«˜åƒ¹æ¨¡å‹
        expensive_model_usage = logs[logs['model'].str.contains('gpt-4')]
        if len(expensive_model_usage) > len(logs) * 0.3:
            opportunities.append({
                'type': 'é«˜åƒ¹æ¨¡å‹ä½¿ç”¨éå¤š',
                'impact': 'medium',
                'suggestion': 'è©•ä¼°æ˜¯å¦å¯ä½¿ç”¨ gpt-5-nano æ›¿ä»£éƒ¨åˆ†æŸ¥è©¢',
                'potential_savings': expensive_model_usage['cost'].sum() * 0.5
            })

        return opportunities

    def generate_optimization_report(self, logs):
        """ç”Ÿæˆå„ªåŒ–å ±å‘Š"""
        breakdown = self.analyze_cost_breakdown(logs)
        opportunities = self.identify_optimization_opportunities(logs)

        total_potential_savings = sum(o['potential_savings'] for o in opportunities)

        return {
            'current_monthly_cost': logs['cost'].sum(),
            'breakdown': breakdown,
            'optimization_opportunities': opportunities,
            'total_potential_savings': total_potential_savings,
            'savings_percentage': (total_potential_savings / logs['cost'].sum()) * 100
        }

# åœ¨å„€è¡¨æ¿ä¸­ä½¿ç”¨
analyzer = CostAnalyzer()
report = analyzer.generate_optimization_report(logs)

st.title("ğŸ’° æˆæœ¬å„ªåŒ–å ±å‘Š")

st.metric(
    "ç•¶å‰æœˆåº¦æˆæœ¬",
    f"${report['current_monthly_cost']:.2f}",
    delta=f"-${report['total_potential_savings']:.2f} æ½›åœ¨ç¯€çœ"
)

st.subheader("ğŸ¯ å„ªåŒ–æ©Ÿæœƒ")
for opp in report['optimization_opportunities']:
    with st.expander(f"{opp['type']} - æ½›åœ¨ç¯€çœ ${opp['potential_savings']:.2f}"):
        st.write(f"**å½±éŸ¿ç­‰ç´š**: {opp['impact']}")
        st.write(f"**å»ºè­°**: {opp['suggestion']}")
```

**é æœŸæ•ˆç›Š**ï¼š
- ğŸ’° æˆæœ¬ç¯€çœ 30-50%
- ğŸ“Š é€æ˜åŒ–æ”¯å‡º
- ğŸ¯ ç²¾æº–å„ªåŒ–

---

## ğŸ“ å¯¦æ–½å„ªå…ˆç´šå»ºè­°

### ğŸ”´ ç«‹å³å¯¦æ–½ï¼ˆç¬¬1é€±ï¼‰

1. **çµ±ä¸€éŒ¯èª¤è™•ç†èˆ‡é‡è©¦æ©Ÿåˆ¶** - ç©©å®šæ€§æœ€é‡è¦
2. **æ—¥èªŒèˆ‡ç›£æ§ç³»çµ±** - äº†è§£ç³»çµ±é‹è¡Œç‹€æ³
3. **æ•æ„Ÿè³‡æ–™è™•ç†** - å®‰å…¨æ€§ä¸èƒ½å¦¥å”
4. **Agent çµæœå¿«å–** - ç«‹å³ç¯€çœæˆæœ¬

**é æœŸæ•ˆç›Š**: ç©©å®šæ€§æå‡ 80%ï¼Œæˆæœ¬é™ä½ 40%

### ğŸŸ¡ è¿‘æœŸå¯¦æ–½ï¼ˆç¬¬2-4é€±ï¼‰

5. **æ‰¹æ¬¡è™•ç†èˆ‡ä¸¦è¡ŒåŸ·è¡Œ** - æ•ˆèƒ½æå‡
6. **å³æ™‚é€²åº¦èˆ‡å–æ¶ˆåŠŸèƒ½** - ç”¨æˆ¶é«”é©—
7. **Agent åŸ·è¡Œæ­·å²** - ä¾¿åˆ©æ€§
8. **è‡ªå‹•åŒ–æ¸¬è©¦æ¡†æ¶** - å“è³ªä¿è­‰
9. **è¼¸å…¥é©—è­‰** - å®‰å…¨æ€§

**é æœŸæ•ˆç›Š**: é€Ÿåº¦æå‡ 2-3å€ï¼Œç”¨æˆ¶æ»¿æ„åº¦æå‡

### ğŸŸ¢ é•·æœŸè¦åŠƒï¼ˆç¬¬2-3å€‹æœˆï¼‰

10. **Agent é–“å”ä½œå·¥ä½œæµ** - åŠŸèƒ½çªç ´
11. **æ™ºèƒ½æ¨¡å‹é¸æ“‡** - æˆæœ¬å„ªåŒ–
12. **å€‹äººåŒ–è¨­å®š** - å·®ç•°åŒ–
13. **åŒ¯å‡ºåˆ†äº«åŠŸèƒ½** - å•†æ¥­åƒ¹å€¼
14. **æ•ˆèƒ½åˆ†æå„€è¡¨æ¿** - æ•¸æ“šé©…å‹•
15. **A/B æ¸¬è©¦æ¡†æ¶** - æŒçºŒå„ªåŒ–
16. **æˆæœ¬åˆ†æ** - ç²¾ç´°åŒ–ç®¡ç†
17. **API Key è¼ªæ›¿** - å®¹éŒ¯æ€§

**é æœŸæ•ˆç›Š**: æˆç‚ºæ¥­ç•Œé ˜å…ˆçš„ AI å»£å‘Šå¹³å°

---

## ğŸ¯ ç¸½çµ

å¯¦æ–½é€™ 17 é …å„ªåŒ–å¾Œï¼Œç³»çµ±å°‡ç²å¾—ï¼š

### æŠ€è¡“æŒ‡æ¨™

- âš¡ **æ•ˆèƒ½æå‡**: 2-5å€
- ğŸ’° **æˆæœ¬é™ä½**: 30-50%
- ğŸ›¡ï¸ **ç©©å®šæ€§**: 99%+
- ğŸ› **éŒ¯èª¤ç‡**: <1%

### å•†æ¥­åƒ¹å€¼

- ğŸ˜Š **ç”¨æˆ¶æ»¿æ„åº¦**: å¤§å¹…æå‡
- ğŸš€ **åŠŸèƒ½è±å¯Œåº¦**: æ¥­ç•Œé ˜å…ˆ
- ğŸ’¼ **å•†æ¥­åŒ–èƒ½åŠ›**: å…·å‚™ä»˜è²»ç”¢å“æ°´æº–
- ğŸ¯ **ç«¶çˆ­åŠ›**: å¸‚å ´ç¨ç‰¹æ€§

### é–‹ç™¼æ•ˆç‡

- ğŸ”§ **ç¶­è­·æˆæœ¬**: é™ä½ 50%
- ğŸ§ª **æ¸¬è©¦è¦†è“‹**: 80%+
- ğŸ“Š **å¯è§€æ¸¬æ€§**: å®Œæ•´é€æ˜
- ğŸš€ **è¿­ä»£é€Ÿåº¦**: æå‡ 3å€

---

**å»ºè­°è¡Œå‹•**ï¼š
1. å…ˆå¯¦æ–½ ğŸ”´ é«˜å„ªå…ˆç´šé …ç›®ï¼ˆ1-2é€±ï¼‰
2. è§€å¯Ÿæ•ˆæœå¾Œæ¨é€² ğŸŸ¡ ä¸­å„ªå…ˆç´šï¼ˆ2-4é€±ï¼‰
3. ç©©å®šå¾Œé€æ­¥åŠ å…¥ ğŸŸ¢ é•·æœŸåŠŸèƒ½

**éœ€è¦è³‡æº**ï¼š
- é–‹ç™¼æ™‚é–“: 20-40 å°æ™‚ï¼ˆé«˜å„ªå…ˆç´šï¼‰
- ç¬¬ä¸‰æ–¹æœå‹™: å¯é¸ï¼ˆç›£æ§ã€åŠ å¯†ç­‰ï¼‰
- æ¸¬è©¦ç’°å¢ƒ: å»ºè­°å»ºç«‹

---

*æ–‡ä»¶ç‰ˆæœ¬: 1.0*
*å»ºè­°ç”±: AI ç³»çµ±åˆ†æ*
*æœ€å¾Œæ›´æ–°: 2025-10-06*
